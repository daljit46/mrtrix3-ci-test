#!/usr/bin/python3

# Copyright (c) 2008-2023 the MRtrix3 contributors.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# Covered Software is provided under this License on an "as is"
# basis, without warranty of any kind, either expressed, implied, or
# statutory, including, without limitation, warranties that the
# Covered Software is free of defects, merchantable, fit for a
# particular purpose or non-infringing.
# See the Mozilla Public License v. 2.0 for more details.
#
# For more details, see http://www.mrtrix.org/.

# pylint: disable=redefined-outer-name,invalid-name,broad-except

import os, codecs, re, glob, sys


cmd_cmake_filename = os.path.join ('cmd', 'targets.cmake')
src_cmake_filename = os.path.join ('src', 'objects.cmake')

include_folders = [ 'core', 'src', 'cmd' ]


re_local_include = re.compile ('^ *\# *include *\"([a-zA-Z0-9/_.]+)\"')
re_system_include = re.compile ('^ *\# *include *<([a-zA-Z0-9/_.]+)>')

full_header_list = dict()


class HeaderList():
  def __init__(self):
    self.system = set()
    self.local = set()



def find_file (filename):
  for folder in include_folders:
    candidate = os.path.join (folder, filename)
    if os.path.isfile (candidate):
      return candidate

  print ('no file found for "' + filename + '"')
  return None



def update_header_list (filename):
  global full_header_list

  if filename in full_header_list.keys():
    return

  if '-debug' in sys.argv:
    print ('listing headers for ' + filename)

  full_header_list[filename] = HeaderList()
  with codecs.open (filename, mode='r', encoding='utf-8') as f:
    for line in f:
      m = re_local_include.match (line)
      if m:
        header = find_file (m.groups()[0])
        if not header:
          raise OSError ('ERROR: header "' + m.groups()[0] + '" not found (from file "' + filename + '", with line "' + line.strip() + '")')
        else:
          full_header_list[filename].local.add (header)
          update_header_list (header)

      else:
        m = re_system_include.match (line)
        if m:
          full_header_list[filename].system.add (m.groups()[0])




def list_all_local_headers_for (filename, headers, system_headers = set()):
  system_headers.update (full_header_list[filename].system)
  for header in full_header_list[filename].local:
    if header not in headers:
      headers.add (header)
      list_all_local_headers_for (header, headers)




def get_link_deps (filename, cpp_deps, system_headers):
  if filename in cpp_deps:
    if '-debug' in sys.argv: print ('"' + filename + '": already processed')
    return

  cpp_deps.add (filename)
  update_header_list (filename)

  headers = set()
  list_all_local_headers_for (filename, headers)

  system_headers.update (full_header_list[filename].system)

  if '-debug' in sys.argv: print ('"' + filename + '": local headers: ' + ' '.join (headers))

  for header in headers:
    system_headers.update (full_header_list[header].system)
    cpp = header[:-1] + 'cpp'
    if os.path.isfile (cpp):
      if '-debug' in sys.argv: print ('"' + filename + '": relies on "' + cpp + '" - adding recursively')
      get_link_deps (cpp, cpp_deps, system_headers)
    else:
      if '-debug' in sys.argv: print ('"' + filename + '": no file "' + cpp + '" - ignoring')



def list_link_deps (cpp):
  linked_cpp, headers, system_headers = set(), set(), set()

  list_all_local_headers_for (cpp, headers, system_headers)
  for f in headers:
    if f.startswith ('src'):
      c = f[:-1]+'cpp'
      if os.path.isfile (c) and c != cpp:
        linked_cpp.add (c)

  return [ linked_cpp, system_headers ]


def object_libname (cpp):
  return '_'.join (cpp[:-4].split(os.path.sep)[1:])



if __name__ == "__main__":

  cmds = [ arg for arg in sys.argv[1:] if not arg.startswith ('-') ]
  if not len (cmds):
    cmds = glob.glob (os.path.join ('cmd', '*.cpp'))
  cmds = [ 'cmd/amp2sh.cpp', 'cmd/mrdegibbs.cpp', 'cmd/dwi2fod.cpp' ]


  cmd_cmake_contents = ''
  src_cpp = set()

  for cmd in sorted(cmds):
    cpp_deps, sys_headers = set(), set()
    get_link_deps (cmd, cpp_deps, sys_headers)
    src_link_cpp = [ cpp for cpp in cpp_deps if cpp.startswith ('src'+os.path.sep) ]
    src_cpp.update (src_link_cpp)

    cmd_cmake_contents += 'add_executable ({} {})\n'.format (os.path.basename (cmd[:-4]), os.path.basename(cmd))
    link_libs = [ '$<TARGET_OBJECTS:'+object_libname(c)+'>' for c in sorted(src_link_cpp) ]
    cmd_cmake_contents += 'target_link_libraries(' + os.path.basename (cmd[:-4]) + ' PRIVATE ' + '\n    '.join([ 'mrtrix::core' ] + link_libs) + ')\n\n'

    if '-verbose' in sys.argv:
      core_cpp, other_cpp = [], []
      for cpp in cpp_deps:
        (core_cpp if cpp.startswith ('core/') else other_cpp).append (cpp)
      print (cmd + ':\n  core cpp deps: ' + ' '.join (core_cpp) + '\n  non-core cpp deps: ' + ' '.join (other_cpp) + '\n  system headers: ' + ' '.join (sys_headers))

  src_cmake_contents = ''
  for cpp in sorted(src_cpp):
    src_cmake_contents += 'add_library (' + object_libname (cpp) + ' OBJECT ' + os.path.relpath (cpp, 'src') + ')\n'
    src_cmake_contents += 'target_include_directories(' + object_libname (cpp) + ' PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})\n'
    [ link_libs, sys_headers ] = list_link_deps (cpp)
    link_libs = [ '$<TARGET_OBJECTS:'+object_libname(c)+'>' for c in sorted(link_libs) ]
    if 'fftw3.h' in sys_headers: link_libs.append ('fftw3')
    if len(link_libs):
      src_cmake_contents += 'target_link_libraries(' + object_libname (cpp) + '\n    '.join ([ ' PUBLIC' ] + link_libs) + ')\n'
    src_cmake_contents += '\n'



  if '-showdeps' in sys.argv:
    for (f, h) in full_header_list.items():
      print (f)
      print ('  local: ' + ' '.join (h.local))
      if len(h.system): print ('  system:  ' + ' '.join (h.system))

  if len(sys.argv) == 1:
    print ('updating "' + cmd_cmake_filename + '"...')
    with codecs.open (cmd_cmake_filename, mode='w', encoding='utf-8') as f:
      f.write (cmd_cmake_contents)
    print ('updating "' + src_cmake_filename + '"...')
    with codecs.open (src_cmake_filename, mode='w', encoding='utf-8') as f:
      f.write (src_cmake_contents)
  else:
    print ('contents of "' + cmd_cmake_filename + '":\n')
    print (cmd_cmake_contents)

    print ('contents of "' + src_cmake_filename + '":\n')
    print (src_cmake_contents)

    print ('running with arguments - files not updated')

